

General:
-----------
rustfmt

cargo [|>] {
    |> new ~ create new project
    |> run ~ build and execute
    |> build
}


Data Types:
--------------

Scalar Types (primitive):
int, float, bool, char.

Compound Types (primitive):
tup, array.

More on Tuples:
> Fixed length, can contain multiple types, 
> optional type annotations can be added. 
< Destructuring a Tuple using pattern matching: 
	let (x, y, z) = tup;

More on Arrays:
> Fixed length, only one type, 
> Data is allocated on the stack rather than the heap. 
> optional type annocations can be added. 
< Declaring an array with the same value for each element:
	let a = [3;5];


Statement vs Expression:
-------------

 Statements perform an action and do not return a value.
 Expressions evaluate to a resulting value. 

< Cannot assign let statement to another variable:
  |    let x = (let y = 6);
  |             ^^^
  = note: let y = 6 is a statement, so x cannot bind to any value

~ Examples of expressions: 
	6
	calling a function
	calling a macro
	{}
	if expressions
	loops 
~


Functions:
--------------
> Use -> to declare return type. 


Control Flow:
--------------
> /If/ and loops are expressions, so you can use them on the right
  side of a let statement. 
> Loops::breaks::returnvalue : break x * 2;
< for loop example:
	for number in (1..4).rev() {
	    println!("{}", number);
	}



Ownership:
------------
> Stack vs Heap
> Ownership basically makes it so you don't have to:
  > keep track of what parts of code are using what data on the heap
  > minimize the amount of duplicate data on the heap
  > and clean up unused data on the heap so you don't run out of space

> Rules:
  - Each value in Rust has a variable that's called its /owner/.
  - There can be only one owner at a time.
  - When the owner goes out of scope, the value will be dropped.

String (Object):
----------------
~ All of the data types covered earlier were primitives and are stored
  on the stack and popped off the stack when their scope was over.
  However, objects like "String" are stored on the heap.

        String Literal(&str) [Primitive]
               {The string's value is known at compile time, so it is
                 hardcoded into the final executable; therefore, it is
                 fast & efficient, but immutable}
        String Object(String) [Object]
               {Able to store an amount of text unknown at compile time.
                 So basically, is /mutable/.}
               {once the object goes out of scope, the memory is
                 automatically returned or deallocated; "drop"}

> The Stack stores primitive data types (local variable; only exists in
  its variable scope) and pointers (to objects in heap).
        Note: pointers are used to locate Objects (dynamically allocated
        blocks of memory) stored somewhere in the heap.

> Heap stores objects.


Data and Variable Interaction:
----------------------
> Move (basically a shallow copy of object, plus original is invalidated)
> Clone (basically a deep copy of object, and original remains true)

~ Side note: an ordinary int can be copied without clone, bc you're
  simply cloning the stack memory (similar to s1/*object*/ = s2).

> The Copy Trait (an annotation that can be placed on most primitives...)
