

General:
-----------
rustfmt

cargo [|>] {
    |> new ~ create new project
    |> run ~ build and execute
    |> build
}


Data Types:
--------------

Scalar Types (primitive):
int, float, bool, char.

Compound Types (primitive):
tup, array.

More on Tuples:
> Fixed length, can contain multiple types, 
> optional type annotations can be added. 
< Destructuring a Tuple using pattern matching: 
	let (x, y, z) = tup;

More on Arrays:
> Fixed length, only one type, 
> Data is allocated on the stack rather than the heap. 
> optional type annocations can be added. 
< Declaring an array with the same value for each element:
	let a = [3;5];


Statement vs Expression:
-------------

 Statements perform an action and do not return a value.
 Expressions evaluate to a resulting value. 

< Cannot assign let statement to another variable:
  |    let x = (let y = 6);
  |             ^^^
  = note: let y = 6 is a statement, so x cannot bind to any value

~ Examples of expressions: 
	6
	calling a function
	calling a macro
	{}
	if expressions
	loops 
~


Functions:
--------------
> Use -> to declare return type. 




Control Flow:
--------------
> /If/ and loops are expressions, so you can use them on the right
  side of a let statement. 
> Loops::breaks::returnvalue : break x * 2;
< for loop example:
	for number in (1..4).rev() {
	    println!("{}", number);
	}


Ownership:
------------
> Stack vs Heap
> Ownership basically makes it so you don't have to:
  > keep track of what parts of code are using what data on the heap
  > minimize the amount of duplicate data on the heap
  > and clean up unused data on the heap so you don't run out of space

> Rules:
  - Each value in Rust has a variable that's called its /owner/.
  - There can be only one owner at a time.
  - When the owner goes out of scope, the value will be dropped.

String (Object):
----------------
~ All of the data types covered earlier were primitives and are stored
  on the stack and popped off the stack when their scope was over.
  However, objects like "String" are stored on the heap.

        String Literal(&str) [Primitive]
               {String value is hardcoded into the program; immutable}
               {know the contents at compile time, so hardcoded into the
                 final executable; fast & efficient, but immutable}
        String Object(String) [Object]
               {Can store an amount of text unknown at compile time}
               {once the object goes out of scope, the memory is
                 automatically returned or deallocated; "drop"}

> Stack stores primitive data types (local variable; exists only in
  variable scope) and pointers (to objects in heap).
        Note: pointers are used to locate Objects (dynamically allocated
        blocks of memory) stored somewhere in the heap.

> Heap stores objects

>
